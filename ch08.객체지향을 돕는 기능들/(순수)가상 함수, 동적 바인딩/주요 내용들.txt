가상 함수 : 다형성을 구현할 때 멤버 함수 가운데 자식 클래스에서 오버라이딩(재정의)
해야하는 함수

가상함수 선언
virtual 반환_형식 함수_이름(매개변수) override;(override은 선택이다.)

가상함수를 사용하면 자식 클래스가 부모 클래스로 변환(부모 객체 = 자식 객체;)되더라도
자식 클래스의 오버라이딩 함수를 사용하다.
이렇게 동작하는 이유는 가상 함수가 '가상 함수 테이블'을 통해 동적으로 바인딩되기 때문이다.

바인딩
프로그램을 실행하면 함수 호출이나 변수 참조가 해당 코드와 연결되는 과정을 말한다.
바인딩은 static binding(컴파일 시점에서 동작), dynamic binding(실행 시점에서 동작)두 종류가 있으며
각각 early binding, late binding이라고도 한다.

정적 바인딩 예시
print_out_array()로 인해 이동할 메모리 주소 0xAE1F4C가 있을 때 그 주소로 이동하도록 컴파일 시점에서 정한다.

C++에서는 가상 함수, 자식 클래스로 치환된 부모 클래스의 포인터가 동적으로 바인딩된다.
정적 : 함수 호출 시 바로 해당 주소로 이동
동적 : 함수 호출 시 해당 객체로 이동한 후 객체가 가리키는 주소로 이동

이런 일이 가능한 이유는 가상 함수 테이블을 가지고 있기 때문이다.
가상함수가 있는 클래스로 객체를 생성하면 메모리에 _vfptr이라는 가상 함수 테이블을 가리키는 포인터가 생기고
객체가 가상 함수를 호출할 때 _vfptr을 사용한다.
가상 함수 테이블은 클래스의 계층 구조에서 최상위 클래스에만 존재한다.
자식 클래스는 부모 클래스의 가상 함수 테이블을 상속받으며,
가상 함수를 오버라이딩할 때 해당 함수의 주소를 가상 함수 테이블에 등록한다.