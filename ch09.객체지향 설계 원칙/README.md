# SOLID 원칙

# SRP (Single Responsibility) 단일 책임 원칙
클래스는 단 한개의 책임을 가져야 함<br>
클래스는 한 가지 기능만을 수행하고 변경하는 이유도 단 하나여야 함<br>
이를 지키지 않으면, 한 클래스의 변경에 의해 다른 클래스와 관련된 코드에 영향을 미칠 수 있음<br>
→ 유지보수가 매우 비효율적<br>

SRP 에서 이야기하는 책임이란, '기능' 정도로 생각하면 된다. 만약 한 클래스가 수행할 수 있는 기능 (책임)이 여러 개라면,<br>
클래스 내부의 함수끼리 강한 결합을 발생할 가능성이 높아진다. 응집도는 높고 결합도는 낮은 프로그램을 설계하는 것이 비로소 객체지향 설계의 핵심인데,<br>
이것이 위반되는 것이다. 새로운 요구사항이나 프로그램 변경에 의해 클래스 내부의 동작들이 연쇄적으로 변경되어야 할 수도 있다.<br>
이는 유지보수가 비효율적이므로, 책임을 잘게 쪼개어 분리시킬 필요가 있다.<br>

이를 위해서 설계 측면, 리팩터링(유지 보수가 쉽게 코드 정리) 측면에서 살펴보자.<br>
설계 측면 : 컴포지션, 어그리게이션 활용<br>
리팩터링 측면 : 클래스를 추출해 거대 클래스를 작은 단위로 나눈다.<br>
이때 나누더라도 논리적 관계는 유지되어야 한다. 또한 상속 관계를 잘 정리해야함.<br>

# OCP (Open-Closed) 개방-폐쇄 원칙
확장에는 열려있어야 하고, 변경에는 닫혀 있어야 함<br>
즉, 기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야 함<br>
ex) 동적 바인딩을 보면 새로운 기능을 추가할 수 있는 방법이 생기며, 다른 코드에 파급효과가 없어 추가되는 기능 외에는 수정이 필요없다.<br>

어떤 모듈의 기능을 하나 수정할 때, 그 모듈을 이용하는 다른 모듈들 역시 줄줄이 고쳐야 한다면 유지보수가 복잡할 것이다.<br>
따라서 개방 폐쇄 원칙을 잘 적용하여 기존 코드를 변경하지 않아도 기능을 새롭게 만들거나 변경할 수 있도록 해야 한다.<br>

그렇지 않으면 객체지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 모두 잃어버리는 셈이고, OOP를 사용하는 의미가 사라지게 된다.

OCP 는 추상 클래스(인터페이스) 와 상속 (다형성) 등을 통해 구현해낼 수 있다.<br>
흐름의 뼈대를 인터페이스로 잡고 살을 붙이는 작업을 클래스에 위임해 설계하는 패턴을 <strong>템플릿 메서드 패턴</strong>이라고 한다.
자주 변화하는 부분을 추상화함으로써 기존 코드를 수정하지 않고도 기능을 확장할 수 있도록 함으로써 유연함을 높이는 것이 핵심이다.<br>
(OCP)template_method_monster.cpp 파일을 보자.<br>
추상 클래스의 주요 기능을 모두 가상 함수로 선언하고 이를 상속받는 자식 클래스에서 가상 함수를 각각 구현한다.<br>
그리고 템플릿 함수에서 자식 클래스의 객체에 오버라이딩된 가상 함수를 호출해 논리의 흐름을 완성시킨다.<br>
만약 확장이 필요하면 자식 클래스를 추가하면 된다.<br>

# LSP (Liskov Substitution) 리스코프 치환 원칙
하위 타입 객체는 상위 타입 객체에서 가능한 행위를 수행할 수 있어야 함<br>
→ 즉, 상위 타입 객체를 하위 타입 객체로 치환해도 정상적으로 동작해야 함<br>
상속관계에서는 꼭 일반화 관계 (IS-A) 가 성립해야 한다는 의미 (일관성 있는 관계인지)<br>
1. 부모 클래스를 상속 받아 구현한 자식 클래스는 부모 클래스로 업캐스팅이 가능<br>
2. 자식 클래스에서 부모 클래스의 멤버 함수를 상속받아 오버라이딩하거나 유지해야한다.<br>

상속관계가 아닌 클래스들을 상속관계로 설정하면, 이 원칙이 위배됨 (재사용 목적으로 사용하는 경우)<br>
결국은, 리스코프 치환 원칙을 지키지 않으면 개방 폐쇄 원칙을 위반하게 되는 것이다. 기능 확장을 위해 기존의 코드를 여러 번 수정해야 할 것이다.<br>
따라서 상속 관계를 잘 정의하여 LSP 원칙이 위배되지 않도록 설계해야 한다.<br>

# ISP (Interface Segregation) 인터페이스 분리 원칙
C++에서는 인터페이스에 대한 공식 정의가 없고 추상 클래스만을 활용함. 따라서 순수 가상 함수만으로 구성된 추상 클래스를 떠올리면 된다.<br>
ISP는 단일 책임 원칙을 인터페이스에 적용한 것으로 생각하면 이해가 쉽다.<br>
단일 책임 원칙을 떠올려 보면 '클래스는 한 가지 기능만 해야하고 한 가지 기능만 변경해야한다.'였다.<br>
인터페이스를 상속받은 클래스에서는 인터페이스를 구현해야한다. 그런데 클래스에서 여러 인터페이스를 구현하다 보면 단일 책임 원칙에 위반된다.<br>
단일 책임 원칙을 지키려면 인터페이스가 작고 섬세(fine grained)해야 하며, 클래스는 역할에 특화된 최소한의 인터페이슬르 구현해야 한다.<br>
-> 인터페이스는 작고 섬세하며, 클래스는 필요한 인터페이스만 구현해야한다.<br>
monster_example.cpp 파일을 보면<br>
기존 몬스터 클래스에 있던 순수 가상 함수들을 이동 인터페이스인 IRoute와 공격 인터페이스인 IAttack으로 분리했다.<br>
이로써 몬스터와 NPC가 이동 인터페이스는 활용하지만,<br>
공격이 필요하지 않은 NPC는 공격 인터페이스를 구현하지 않고 필요한 인터페이스만 구현할 수 있다.

# DIP (Dependency Inversion) 의존 역전 원칙
상위 수준 모듈은 하위 수준의 모듈에 의존해서는 안되며 상위 하위 수준 모두 추상 레이어(인터페이스)에 의존해야한다.<br>
의존 관계를 맺을 때, 변하기 쉬운 것 (구체적인 것) 보다는 변하기 어려운 것 (추상적인 것)에 의존해야 함<br>
→ 구체화된 클래스에 의존하기 보다는 추상 클래스나 인터페이스에 의존해야 한다는 뜻<br>

즉, 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 됨<br>
저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 함<br>
저수준 모듈이 변경되어도 고수준 모듈은 변경이 필요없는 형태가 이상적<br>
(DIP)monster_example.cpp를 보면 탈것과 무기를 관리하는 인터페이스를 추가하고 플레이어는 인터페이스를 참조하도록 하였다.<br>
이렇게 의존성 역전 원칙을 적용하면 무기나 탈것을 추가하더라도 플레이어 클래스는 변경하지 않고 확장할 수 있다.<br>

# 총 정리<br>
SRP 와 ISP 는 객체가 커지는 것을 막아준다.<br>
객체가 단일 책임을 갖도록 하고 클라이언트마다 특화된 인터페이스를 구현하게 함으로써 한 기능의 변경이 다른 곳까지 미치는 영향을 최소화하고,<br>
이는 기능 추가 및 변경에 용이하도록 만들어 준다.<br>

LSP 와 DIP 는 OCP 를 서포트한다.<br>
OCP 는 자주 변화되는 부분을 추상화하고 다형성을 이용함으로써 기능 확장에는 용이하되 기존 코드의 변화에는 보수적이도록 만들어 준다.<br>
여기서 '변화되는 부분을 추상화'할 수 있도록 도와주는 원칙이 DIP 이고, 다형성 구현을 도와주는 원칙이 LSP 인 것이다.<br>