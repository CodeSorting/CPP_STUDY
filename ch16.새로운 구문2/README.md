# 폴드 표현식
C++17에서부터 도입된 폴드 표현식은 개수가 정해지지 않은 매개변수를<br>
하나로 묶은 매개변수 팩을 반복해서 계산해준다.<br>
C++11부터 도입된 가변 인수 템플릿의 재귀 호출을 함수 하나로 표현할 수 있는 방법이다.<br>
함수의 매개변수 개수는 일반적으로 소스 코드를 작성하는 시점에 정한다.<br>
하지만 매개변수의 개수를 알 수 없거나 필요에 따라 가변 개수의 인자를 사용하고 싶을 때가 있다.<br>
모던 C++에서는 가변 인자를 허용하는 함수를 선언할 때 템플릿과 매개변수 팩을 이용한다.<br>
매개변수 팩은 데이터 형식과 개수가 모두 정해지지 않은 템플릿 매개변수들을 하나로 묶어준다.<br>

폴드 표현식의 4가지 형태<br>
정수 1,2,3,4 4개로 구성되어 있는 int_pack 덧셈 예시<br>
1. (int_pack + ...) : 단항 오른쪽 -> (((1 + 2) + 3) + 4)
2. (... + int_pack) : 단항 왼쪽 -> (1 + (2 + (3 + 4)))
3. (int_pack + ... + init) : 이항 오른쪽 -> ((((0 + 1) + 2) + 3) + 4)
4. (init + ... + int_pack) : 이항 왼쪽 -> (0 + (1 + (2 + (3 + 4))))

# 3방향 비교 연산자
```
//a,b가 클래스의 객체일 때는 비교 연산자 오버로딩을 6개나 해야한다.
if (a==b) {}
else if (a>b) {}
else {}
```
이를 해결하기 위해 우주선 연산자(3방향 비교 연산자) <=>를 사용하여 하나만 오버로딩하게 한다.<br>
3방향 비교 연산자를 사용하려면 소스에 <compare> 헤더를 포함해야한다.<br>
a<=>b에서<br>
a == b일 때 0<br>
a > b일 때 1<br>
a < b이면 -1<br>
비교가 불가하면 -128로 변환한다.<br>

#### 반환 타입
3방향 비교 연산자는 아래 세 가지 타입 중 하나를 반환한다:<br>
std::strong_ordering:<br>
완전한 정렬 순서가 정의된 경우.<br>
예: 정수, 실수, 문자열<br>

std::weak_ordering:<br>
대체로 정렬이 가능하지만 완전한 순서가 보장되지 않는 경우.<br>
예: 문자열의 대소문자 구분 없이 비교.도형, 집합 등 동치 관계 성립<br>

std::partial_ordering:<br>
일부 값에 대해 비교 불가능한 경우.<br>
예: NaN이 포함된 float 또는 double.(-128 반환)<br>

# using 키워드
using 키워드는 상속 멤버 접근 지정자 변경, 열거형 사용 선언, 별칭 만들기 등 다양한 활용법이 있다.<br>

상속 멤버의 접근 지정자 변경 : using_declarations_class_members.cpp를 보면 protected로 선언된 get_damage()를<br>
자식 클래스에서 using monster::get_damage;를 public 안으로 넣어 public 함수로 접근 지정자를 변경했다.<br>

열거형 사용 선언 : 열거형을 선언한 후에 구조체나 클래스 내부에서 사용할 때는 열거형 이름과 함께 사용하면 된다.<br>
만약 열거형 선언을 구조체나 클래스 내부에 있는 데이터 형식처럼 사용하려면 해당 클래스나 구조체에서 using 키워드로 선언하면 된다.<br>
이렇게 하면 열거형과 구조체 또는 클래스 간의 관계를 논리적으로 만들 수 있다.<br>
using_declarations_enum.cpp를 보면 열거형 사용을 구조체나 클래스 내부에 using으로 선언하면<br>
비록 외부에 정의된 열거형이라도 내부에 정의된 열거형처럼 사용할 수 있어서 소스 코드에서 논리관계를 쉽게 파악할 수 있다는걸 알 수 있다.<br>

별칭 만들기 : using으로 typedef처럼 alias를 만들 수 있다.<br>
using 별칭 = 식별자로 나타낼 수 있다.<br>
ex) using DATA = struct _tag;

# 함수 키워드(default,delete,override,final)
함수를 만들 때 키워드들을 쓰면 함수를 만든 목적과 사용방법을 명확히 함으로써 개발자 본인과 공동작업자가 정확히 이해할 수 있다.<br>
함수의 목적과 사용방법을 알리는 방법은 잘못 사용했을 때 컴파일이 안되게 하는 것이다.<br>

default : 기본으로 제공되는 함수 사용<br>
default 키워드를 사용하면 생성자의 경우는 매개변수가 없는 기본 생성자가 호출되고, 연산자는 오버로딩되지 않은 기본 연산자가 호출된다.<br>

delete : 삭제되어 더이상 사용하지 않는 함수에 사용<br>
ex) void create() = delete;로 하면 함수를 호출해도 삭제된 함수라고 출력됨.<br>

override : 재정의 함수<br>
가상함수를 상속받고 재정의하는건지, 이름을 착각해 중복해 쓴건지 구분하기 위함이다.<br>
ex) virtual function(...) override {};

final : 재정의 금지<br>
특정 시점에 가상함수의 재정의나 클래스, 구조체의 상속을 막으려면 최종 상속 단계에서 final 키워드를 추가하면 된다.<br>
ex) class class_name final : base_classes {};,struct struct_name final : base_classes {};




